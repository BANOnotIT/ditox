{"version":3,"file":"index.js","sources":["../src/ditox.ts","../src/utils.ts"],"sourcesContent":["/**\n * @ignore\n * Binding token for mandatory value\n */\nexport type RequiredToken<T> = {\n  symbol: symbol;\n  type?: T; // Anchor for Typescript type inference.\n  isOptional?: false;\n};\n\n/**\n * @ignore\n * Binding token for optional value\n */\nexport type OptionalToken<T> = {\n  symbol: symbol;\n  type?: T; // Anchor for Typescript type inference.\n  isOptional: true;\n  optionalValue: T;\n};\n\n/**\n * Binding token.\n */\nexport type Token<T> = RequiredToken<T> | OptionalToken<T>;\n\n/**\n * Creates a new binding token.\n * @param description - Token description for better error messages.\n */\nexport function token<T>(description?: string): Token<T> {\n  return {symbol: Symbol(description)};\n}\n\n/**\n * Decorate a token with an optional value.\n * This value is be used as default value in case a container does not have registered token.\n * @param token - Existed token.\n * @param optionalValue - Default value for the resolver.\n */\nexport function optional<T>(\n  token: Token<T>,\n  optionalValue: T,\n): OptionalToken<T>;\nexport function optional<T>(token: Token<T>): OptionalToken<T | undefined>;\nexport function optional<T>(\n  token: Token<T>,\n  optionalValue?: T,\n): OptionalToken<T | undefined> {\n  return {\n    symbol: token.symbol,\n    isOptional: true,\n    optionalValue,\n  };\n}\n\n/**\n * ResolverError is thrown by the resolver when a token is not found in a container.\n */\nexport class ResolverError extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = 'ResolverError';\n  }\n}\n\n/**\n * @see https://github.com/mnasyrov/ditox#factory-lifetimes\n */\nexport type FactoryScope = 'scoped' | 'singleton' | 'transient';\n\n/**\n * Options for factory binding.\n *\n * `scope` types:\n *   - `scoped` - **This is the default**. The value is created and cached by the container which starts resolving.\n *   - `singleton` - The value is created and cached by the container which registered the factory.\n *   - `transient` - The value is created every time it is resolved.\n *\n * `scoped` and `singleton` scopes can have `onRemoved` callback. It is called when a token is removed from the container.\n */\nexport type FactoryOptions<T> =\n  | {\n      scope?: 'scoped' | 'singleton';\n      onRemoved?: (value: T) => void;\n    }\n  | {\n      scope: 'transient';\n    };\n\n/**\n * Dependency container.\n */\nexport type Container = {\n  /**\n   * Binds a value for the token\n   */\n  bindValue<T>(token: Token<T>, value: T): void;\n\n  /**\n   * Binds a factory for the token.\n   */\n  bindFactory<T>(\n    token: Token<T>,\n    factory: (container: Container) => T,\n    options?: FactoryOptions<T>,\n  ): void;\n\n  /**\n   * Returns a resolved value by the token, or returns `undefined` in case the token is not found.\n   */\n  get<T>(token: Token<T>): T | undefined;\n\n  /**\n   * Returns a resolved value by the token, or throws `ResolverError` in case the token is not found.\n   */\n  resolve<T>(token: Token<T>): T;\n\n  /**\n   * Removes a binding for the token.\n   */\n  remove<T>(token: Token<T>): void;\n\n  /**\n   * Removes all bindings in the container.\n   */\n  removeAll(): void;\n};\n\n/** @internal */\nexport const CONTAINER: Token<Container> = token('ditox.Container');\n/** @internal */\nexport const PARENT_CONTAINER: Token<Container> = token(\n  'ditox.ParentContainer',\n);\n/** @internal */\nexport const RESOLVER: Token<Resolver> = token('ditox.Resolver');\n\n/** @internal */\nconst NOT_FOUND = Symbol();\n\n/** @internal */\nconst DEFAULT_SCOPE: FactoryScope = 'scoped';\n\n/** @internal */\ntype FactoryContext<T> = {\n  factory: (container: Container) => T;\n  options?: FactoryOptions<T>;\n};\n\n/** @internal */\ntype ValuesMap = Map<symbol, any>;\n\n/** @internal */\ntype FactoriesMap = Map<symbol, FactoryContext<any>>;\n\n/** @internal */\ntype ResolverResult<T> =\n  | {type: 'value'; value: T}\n  | {type: 'factory'; factoryContext: FactoryContext<T>};\n\n/** @internal */\ntype Resolver = <T>(token: Token<T>) => ResolverResult<T> | undefined;\n\n/** @internal */\nfunction getScope<T>(options?: FactoryOptions<T>): FactoryScope {\n  return options?.scope ?? DEFAULT_SCOPE;\n}\n\n/** @internal */\nfunction getOnRemoved<T>(options: FactoryOptions<T>) {\n  return options.scope === undefined ||\n    options.scope === 'scoped' ||\n    options.scope === 'singleton'\n    ? options.onRemoved\n    : undefined;\n}\n\n/** @internal */\nfunction isInternalToken<T>(token: Token<T>): boolean {\n  return (\n    token.symbol === CONTAINER.symbol ||\n    token.symbol === PARENT_CONTAINER.symbol ||\n    token.symbol === RESOLVER.symbol\n  );\n}\n\n/**\n * Creates a new dependency container.\n *\n * Container can have an optional parent to chain token resolution. The parent is used in case the current container does not have a registered token.\n *\n * @param parentContainer - Optional parent container.\n */\nexport function createContainer(parentContainer?: Container): Container {\n  const values: ValuesMap = new Map<symbol, any>();\n  const factories: FactoriesMap = new Map<symbol, FactoryContext<any>>();\n\n  const container: Container = {\n    bindValue<T>(token: Token<T>, value: T): void {\n      if (isInternalToken(token)) {\n        return;\n      }\n\n      values.set(token.symbol, value);\n    },\n\n    bindFactory<T>(\n      token: Token<T>,\n      factory: (container: Container) => T,\n      options?: FactoryOptions<T>,\n    ): void {\n      if (isInternalToken(token)) {\n        return;\n      }\n\n      factories.set(token.symbol, {factory, options});\n    },\n\n    remove<T>(token: Token<T>): void {\n      if (isInternalToken(token)) {\n        return;\n      }\n\n      const options = factories.get(token.symbol)?.options;\n      if (options) {\n        executeOnRemoved(token.symbol, options);\n      }\n\n      values.delete(token.symbol);\n      factories.delete(token.symbol);\n    },\n\n    removeAll(): void {\n      factories.forEach((context, tokenSymbol) => {\n        if (context.options) {\n          executeOnRemoved(tokenSymbol, context.options);\n        }\n      });\n\n      values.clear();\n      factories.clear();\n      bindInternalTokens();\n    },\n\n    get<T>(token: Token<T>): T | undefined {\n      const value = localResolver(token);\n      if (value !== NOT_FOUND) {\n        return value;\n      }\n\n      if (token.isOptional) {\n        return token.optionalValue;\n      }\n\n      return undefined;\n    },\n\n    resolve<T>(token: Token<T>): T {\n      const value = localResolver(token);\n      if (value !== NOT_FOUND) {\n        return value;\n      }\n\n      if (token.isOptional) {\n        return token.optionalValue;\n      }\n\n      throw new ResolverError(\n        `Token \"${token.symbol.description ?? ''}\" is not provided`,\n      );\n    },\n  };\n\n  function localResolver<T>(token: Token<T>): T | typeof NOT_FOUND {\n    const result = resolver(token);\n\n    if (result) {\n      if (result.type === 'value') {\n        return result.value;\n      }\n\n      if (result.type === 'factory') {\n        const context = result.factoryContext;\n        const value = context.factory(container);\n\n        const scope = getScope(context.options);\n        if (scope === 'singleton' || scope === 'scoped') {\n          // Cache the value in the local container.\n          values.set(token.symbol, value);\n        }\n\n        return value;\n      }\n    }\n\n    return NOT_FOUND;\n  }\n\n  function resolver<T>(token: Token<T>): ResolverResult<T> | undefined {\n    const value = values.get(token.symbol);\n    if (value !== undefined || values.has(token.symbol)) {\n      return {type: 'value', value};\n    }\n\n    const factoryContext = factories.get(token.symbol);\n    if (factoryContext) {\n      const scope = getScope(factoryContext.options);\n\n      if (scope === 'singleton') {\n        // Cache the value in the same container where the factory is registered.\n        const value = factoryContext.factory(container);\n        values.set(token.symbol, value);\n        return {type: 'value', value};\n      }\n\n      return {type: 'factory', factoryContext};\n    }\n\n    const parentResolver = parentContainer?.get(RESOLVER);\n    if (parentResolver) {\n      return parentResolver(token);\n    }\n\n    return undefined;\n  }\n\n  function executeOnRemoved<T>(\n    tokenSymbol: symbol,\n    options: FactoryOptions<T>,\n  ) {\n    const onRemoved = getOnRemoved(options);\n    if (onRemoved) {\n      const value = values.get(tokenSymbol);\n      if (value !== undefined || values.has(tokenSymbol)) {\n        onRemoved(value);\n      }\n    }\n  }\n\n  function bindInternalTokens() {\n    values.set(CONTAINER.symbol, container);\n    values.set(RESOLVER.symbol, resolver);\n\n    if (parentContainer) {\n      values.set(PARENT_CONTAINER.symbol, parentContainer);\n    }\n  }\n\n  bindInternalTokens();\n  return container;\n}\n","import {Container, Token} from './ditox';\n\n/**\n * Decorates a factory by passing resolved tokens as factory arguments.\n * @param factory - A factory.\n * @param tokens - Tokens which correspond to factory arguments.\n * @return Decorated factory which takes a dependency container as a single argument.\n */\nexport function injectable<\n  Tokens extends Token<unknown>[],\n  Values extends {\n    [K in keyof Tokens]: Tokens[K] extends Token<infer V> ? V : never;\n  },\n  Result\n>(\n  factory: (...params: Values) => Result,\n  ...tokens: Tokens\n): (container: Container) => Result {\n  return (container) => {\n    const values: Values = tokens.map(container.resolve) as Values;\n    return factory(...values);\n  };\n}\n\n/**\n * Rebinds the array by the token with added new value.\n * @param container - Dependency container.\n * @param token - Token for an array of values.\n * @param value - New value which is added to the end of the array.\n */\nexport function bindMultiValue<T>(\n  container: Container,\n  token: Token<Array<T>>,\n  value: T,\n): void {\n  const prevValues = container.get(token) ?? [];\n  const nextValues = [...prevValues, value];\n  container.bindValue(token, nextValues);\n}\n\n/**\n * Returns an array of resolved values by the specified token.\n * If a token is not found, then `undefined` value is used.\n */\nexport function getValues<\n  Tokens extends Token<unknown>[],\n  Values extends {\n    [K in keyof Tokens]: Tokens[K] extends Token<infer V> ? V : never;\n  }\n>(container: Container, ...tokens: Tokens): Values {\n  return tokens.map(container.get) as Values;\n}\n\n/**\n * Returns an array of resolved values by the specified token.\n * If a token is not found, then `ResolverError` is thrown.\n */\nexport function resolveValues<\n  Tokens extends Token<unknown>[],\n  Values extends {\n    [K in keyof Tokens]: Tokens[K] extends Token<infer V> ? V : never;\n  }\n>(container: Container, ...tokens: Tokens): Values {\n  return tokens.map(container.resolve) as Values;\n}\n"],"names":[],"mappings":"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"}